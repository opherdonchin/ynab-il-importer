# ynab-il-importer — Execution Plan (to first end-to-end run)

## Goal (Milestone 1)

Produce a repeatable end-to-end pipeline that:

1) Ingests **bank + credit card** exports
2) Normalizes to a single transaction schema
3) De-duplicates against YNAB (API) for a chosen date range
4) Uses `payee_map.csv` to assign payee+category
5) Emits a **reviewable proposed_transactions table**
6) After review, uploads only new transactions to YNAB
7) Generates `payee_map` updates from review decisions

Success criteria:
- For a typical recent month, ≥90% of new transactions are **defaulted** or easily resolved in review
- Upload is **idempotent** (safe to re-run without duplicating)
- `payee_map.csv` evolves cleanly over time (minimal duplication, stable fingerprints)


---

## Core artifacts (v1)

### 1) `mappings/payee_map.csv` (source of truth)

Grain: **one row = one (fingerprint → payee, category) option**.

Required columns:
- `fingerprint_hash`
- `payee_canonical`
- `category`
- `is_default`   (blank or TRUE)
- `count`        (bootstrap hint; optional but useful)
- `active`       (TRUE/blank means active; FALSE means ignore)
- `note`         (free text)

Rules:
- Multiple rows per fingerprint are allowed.
- At most one `is_default=TRUE` per fingerprint.
- `active=FALSE` rows are ignored.
- `category` must be non-empty for final export/upload usage.

Delimiter policy:
- Canonical payees/categories must not contain `;` (reserved delimiter for list columns elsewhere).


### 2) `outputs/proposed_transactions.csv` (review sheet)

Grain: **one row per candidate transaction to upload** (after removing already-present YNAB txns).

Required columns:
- `transaction_id` (stable per parsed txn; used for overrides and logging)
- `date`
- `amount_ils` (signed, consistent convention)
- `memo` (original description)
- `fingerprint_hash`
- `payee_options`     (semicolon-delimited)
- `category_options`  (semicolon-delimited)
- `payee_selected`    (single value or blank)
- `category_selected` (single value or blank)
- `match_status` in {`unmatched`, `needs_choice`, `defaulted`}
- `update_map` (blank/TRUE) — if TRUE, generate a new/updated mapping row from selection
- `note` (optional)

Validation rule:
- `category_selected` must be filled for upload. (Block upload otherwise.)


### 3) `outputs/map_updates.csv` (generated from review)

Grain: one row per unique `(fingerprint_hash, payee_selected, category_selected)` to be added to map.

Columns:
- `fingerprint_hash`
- `payee_canonical`
- `category`
- `is_default` (blank by default; user can promote later)
- `count` (blank)
- `active` (TRUE)
- `note` (e.g., “from review YYYY-MM-DD”)


---

## Phase 0 — Freeze assumptions (one-time)

0.1 Freeze fingerprint algorithm (v1)
- Confirm the current `fingerprint_hash` definition and keep it stable.
- Do not change the algorithm during Milestone 1.
- If future improvements are needed: add `fingerprint_hash_v2` while continuing to compute v1.

0.2 Confirm amount/date conventions
- Single authoritative date per source:
  - bank: purchase date if available, else posting date
  - card: transaction date
- Amount sign convention fixed across sources (e.g., outflows negative).

Deliverable:
- A short “schema + conventions” section in docs/SCHEMA.md (or inside this plan).


---

## Phase 1 — Normalize credit card exports (highest leverage next engineering task)

1.1 Identify supported credit card source(s)
- Define exact input formats (e.g., Max CSV export, Isracard, Cal, etc.).
- Build a parser per source that emits the same normalized schema as bank parsing.

1.2 Implement `parse-card` command(s)
- Output normalized rows with:
  - `date`, `amount_ils`, `memo`, `txn_kind`, `source`, `account_name`,
    `description_clean`, `description_clean_norm`, `fingerprint_hash`

1.3 Golden fixture tests
- Add small test inputs for each card source.
- Snapshot expected normalized output.

Deliverables:
- Card parsing produces coherent grouping and stable fingerprints.
- Unit tests / fixtures for at least one real export sample.


---

## Phase 2 — Bootstrap initial payee_map from historical data

2.1 Pull historical inputs
- Bank exports: multiple months (enough to cover common merchants)
- Card exports: multiple months
- YNAB: download transactions for same date range via API

2.2 Match parsed transactions ↔ YNAB transactions (bootstrap matching)
Goal: infer `(fingerprint_hash → payee, category)` candidates from what already exists in YNAB.

Approach (v1 pragmatic):
- Match on (date, amount) with a tolerance window if needed (±1 day optional)
- Use memo similarity as a tie-break when multiple candidates exist
- Keep conservative: prefer fewer false matches over aggressive linking

2.3 Aggregate into candidate map rows
For each fingerprint:
- Count occurrences by `(payee, category)`
- Emit rows sorted by count desc
- Mark `is_default=TRUE` for the most frequent option *only if* it is clearly dominant (optional heuristic), else leave blank.

Deliverables:
- `mappings/payee_map.csv` created (or `payee_map_bootstrap.csv` to be curated into payee_map.csv)
- A report: how many fingerprints have 1 option vs many, and top ambiguous cases


---

## Phase 3 — Mapping review (manual curation)

3.1 User edits `mappings/payee_map.csv`
Actions:
- delete rows
- fix canonical payee names
- fix categories
- set or remove defaults
- disable rows with `active=FALSE`

3.2 Validation tooling
- A command `validate-payee-map` that checks:
  - no `;` in payees/categories
  - at most one default per fingerprint
  - required columns exist
  - no duplicate identical rows (warn)

Deliverables:
- payee_map is curated and passes validation.


---

## Phase 4 — Regular processing pipeline (end-to-end dry run)

4.1 Download “new” bank/card transactions
- Parse and normalize into unified schema

4.2 Download YNAB transactions for relevant date range
- Use API to pull all transactions in range (per account)
- Build an index of existing items for dedupe

4.3 Dedupe (remove already present)
- Primary method (preferred): deterministic `import_id` if we implement it
- Fallback method (v1): (date, amount, memo fingerprint) heuristic

4.4 Apply payee_map to remaining transactions
For each txn:
- Collect all active map rows by fingerprint_hash
- Build:
  - `payee_options` = unique payees
  - `category_options` = unique categories
- Determine selected:
  - if only one active row → prefill payee_selected + category_selected
  - else if exactly one default row → prefill from default
  - else leave blank (needs choice)

Set `match_status`:
- no rows → unmatched
- selected filled → defaulted
- else → needs_choice

4.5 Emit `outputs/proposed_transactions.csv`
- Include `update_map` column (blank by default)

Deliverable:
- Full dry-run output that is reviewable and mostly defaulted.


---

## Phase 5 — Transaction review UI (simple, high-quality, local)

5.1 Implement a local review app (Streamlit recommended)
Features:
- Load `outputs/proposed_transactions.csv`
- Dropdown for `payee_selected` (from payee_options)
- Dropdown for `category_selected` (from category_options, AND/OR full category list)
- Checkbox `update_map`
- Save edits back to CSV

5.2 Enforce category selection
- Block “ready to upload” until all selected categories filled

Deliverable:
- Reviewed `proposed_transactions.csv` ready to upload.


---

## Phase 6 — Update stage (map + upload)

6.1 Generate `outputs/map_updates.csv`
From reviewed transactions:
- For rows with `update_map=TRUE`, create unique mapping triples:
  `(fingerprint_hash, payee_selected, category_selected)`
- Append (or merge) into `mappings/payee_map.csv`
  - default `active=TRUE`
  - default `is_default` blank (user can promote later)

6.2 Upload to YNAB (first real end-to-end run)
- Convert reviewed txns into API payload
- Upload only deduped “new” txns
- Log results:
  - uploaded count
  - skipped count (already present)
  - failures with reasons

Deliverables:
- Transactions appear in YNAB correctly categorized
- Rerun is safe (idempotent)


---

## Phase 7 — Iteration loop (steady state)

Weekly/monthly cycle:
1) parse new exports
2) dedupe against YNAB
3) apply map → propose
4) review + mark update_map when needed
5) append map updates
6) upload

Metrics to watch:
- % defaulted
- % needs_choice
- % unmatched
- number of new fingerprints per period

Stop condition for “stable enough”:
- needs_choice + unmatched consistently low and manageable